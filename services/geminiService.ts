
import { GoogleGenAI, Modality, Part } from "@google/genai";

const fileToGenerativePart = async (file: File) => {
  const base64 = await new Promise<string>((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve((reader.result as string).split(',')[1]);
    reader.onerror = error => reject(error);
  });
  return {
    inlineData: {
      mimeType: file.type,
      data: base64,
    },
  };
};

const generateConsistentCharacterImage = async (
  prompt: string,
  characterFiles: File[],
  backgroundFile: File | null,
  useBackground: boolean,
  aspectRatio: string
): Promise<string> => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  
  const parts: Part[] = [];

  for (const file of characterFiles) {
    parts.push(await fileToGenerativePart(file));
  }

  let fullPrompt = `You are an expert character concept artist. Your task is to generate a new image based on reference materials.
Reference Characters: I have provided one or more character images. You MUST maintain their exact design, features, and art style.
Action/Scene: The new image should depict the following scene: "${prompt}".
`;

  if (backgroundFile && useBackground) {
    fullPrompt += `Background: Use the provided background image as the setting for the scene. The characters should be integrated naturally into this background.`;
    parts.push(await fileToGenerativePart(backgroundFile));
  } else {
    fullPrompt += `Background: Create a new, suitable background that fits the scene.`;
  }

  fullPrompt += `
Output Requirements:
- The final output should be a single, high-quality 4K image with an aspect ratio of ${aspectRatio}.
- The character(s) in the output must be consistent with the reference character(s).
- The art style must be consistent with the reference character(s).
`;
  
  parts.push({ text: fullPrompt });

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image',
    contents: { parts },
    config: {
        responseModalities: [Modality.IMAGE, Modality.TEXT],
    },
  });

  for (const part of response.candidates[0].content.parts) {
    if (part.inlineData) {
      return part.inlineData.data;
    }
  }

  throw new Error("No image was generated by the API. The prompt may have been blocked.");
};

export const generateOneImage = async (
  prompt: string,
  characterFiles: File[],
  backgroundFile: File | null,
  useBackground: boolean,
  aspectRatio: string
): Promise<string> => {
    if (!process.env.API_KEY) {
        throw new Error("API key is missing. Please set the API_KEY environment variable.");
    }
    const base64 = await generateConsistentCharacterImage(prompt, characterFiles, backgroundFile, useBackground, aspectRatio);
    return `data:image/png;base64,${base64}`;
};

export const generateFourImages = async (
  prompt: string,
  characterFiles: File[],
  backgroundFile: File | null,
  useBackground: boolean,
  aspectRatio: string
): Promise<string[]> => {
    if (!process.env.API_KEY) {
        throw new Error("API key is missing. Please set the API_KEY environment variable.");
    }

    const promises = Array(4).fill(null).map(() => 
        generateConsistentCharacterImage(prompt, characterFiles, backgroundFile, useBackground, aspectRatio)
    );
    const results = await Promise.all(promises);
    return results.map(base64 => `data:image/png;base64,${base64}`);
}